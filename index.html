<!DOCTYPE html>
<html>
<head>
  <title>PDF Manipulation</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js" integrity="sha512-z8IYLHO8bTgFqj+yrPyIJnzBDf7DDhWwiEsk4sY+Oe6J2M+WQequeGS7qioI5vT6rXgVRb4K1UVQC5ER7MKzKQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script></head>
<body>
  <h1>PDF Manipulation</h1>

  <input type="file" id="inputFiles" multiple>
  <button onclick="mergePDFs()">Merge PDFs</button>
  <button onclick="splitPDFs()">Split PDFs</button>
  <button onclick="extractPages()">Extract Pages</button>
  <button onclick="rearrangePages()">Rearrange Pages</button>
  <button onclick="createGroupPDFs()">Create Group PDFs</button>

  <script>
    async function mergePDFs() {
      const inputFiles = document.getElementById('inputFiles').files;
      const mergedPDF = await PDFLib.PDFDocument.create();

      for (const file of inputFiles) {
        const reader = new FileReader();

        reader.onload = async function() {
          const pdfBytes = new Uint8Array(reader.result);
          const pdf = await PDFLib.PDFDocument.load(pdfBytes);
          const pages = await mergedPDF.copyPages(pdf, pdf.getPageIndices());

          pages.forEach((page) => {
            mergedPDF.addPage(page);
          });

          if (file === inputFiles[inputFiles.length - 1]) {
            const mergedPdfBytes = await mergedPDF.save();
            downloadPDF(mergedPdfBytes, 'merged.pdf');
          }
        };

        reader.readAsArrayBuffer(file);
      }
    }

    async function splitPDFs() {
      const inputFiles = document.getElementById('inputFiles').files;

      for (const file of inputFiles) {
        const reader = new FileReader();

        reader.onload = async function() {
          const pdfBytes = new Uint8Array(reader.result);
          const pdf = await PDFLib.PDFDocument.load(pdfBytes);
          const pageCount = pdf.getPageCount();

          for (let i = 0; i < pageCount; i++) {
            const newPDF = await PDFLib.PDFDocument.create();
            const [copiedPage] = await newPDF.copyPages(pdf, [i]);
            newPDF.addPage(copiedPage);

            const splitPdfBytes = await newPDF.save();
            const filename = `split_page_${i + 1}.pdf`;
            downloadPDF(splitPdfBytes, filename);
          }
        };

        reader.readAsArrayBuffer(file);
      }
    }

    async function extractPages() {
      const inputFiles = document.getElementById('inputFiles').files;

      for (const file of inputFiles) {
        const reader = new FileReader();

        reader.onload = async function() {
          const pdfBytes = new Uint8Array(reader.result);
          const pdf = await PDFLib.PDFDocument.load(pdfBytes);
          const pageCount = pdf.getPageCount();

          const startPage = parseInt(prompt('Enter the start page number:'));
          const endPage = parseInt(prompt('Enter the end page number:'));

          if (isNaN(startPage) || isNaN(endPage) || startPage < 1 || endPage > pageCount || startPage > endPage) {
            alert('Invalid page numbers!');
            return;
          }

          const newPDF = await PDFLib.PDFDocument.create();

          for (let i = startPage - 1; i < endPage; i++) {
            const [copiedPage] = await newPDF.copyPages(pdf, [i]);
            newPDF.addPage(copiedPage);
          }

         
          const extractedPdfBytes = await newPDF.save();
          const filename = 'extracted_pages_${startPage}_to_${endPage}.pdf';
          downloadPDF(extractedPdfBytes, filename);
          };
              reader.readAsArrayBuffer(file);
  }
}

async function rearrangePages() {
  const inputFiles = document.getElementById('inputFiles').files;

  for (const file of inputFiles) {
    const reader = new FileReader();

    reader.onload = async function() {
      const pdfBytes = new Uint8Array(reader.result);
      const pdf = await PDFLib.PDFDocument.load(pdfBytes);
      const pageCount = pdf.getPageCount();

      const order = prompt('Enter the new page order (comma-separated numbers):');
      const pageIndexes = order.split(',').map(num => parseInt(num.trim()));

      if (!isValidPageOrder(pageIndexes, pageCount)) {
        alert('Invalid page order!');
        return;
      }

      const newPDF = await PDFLib.PDFDocument.create();

      for (const pageIndex of pageIndexes) {
        if (pageIndex < 1 || pageIndex > pageCount) {
          continue;
        }

        const [copiedPage] = await newPDF.copyPages(pdf, [pageIndex - 1]);
        newPDF.addPage(copiedPage);
      }

      const rearrangedPdfBytes = await newPDF.save();
      const filename = `rearranged_pages.pdf`;
      downloadPDF(rearrangedPdfBytes, filename);
    };

    reader.readAsArrayBuffer(file);
  }
}

async function createGroupPDFs() {
  const inputFiles = document.getElementById('inputFiles').files;

  const groups = prompt('Enter the group numbers for each PDF (comma-separated numbers):');
  const groupNumbers = groups.split(',').map(num => parseInt(num.trim()));

  if (!isValidGroupNumbers(groupNumbers, inputFiles.length)) {
    alert('Invalid group numbers!');
    return;
  }

  const groupedPDFs = {};

  for (let i = 0; i < inputFiles.length; i++) {
    const file = inputFiles[i];
    const groupNumber = groupNumbers[i];

    if (!groupedPDFs[groupNumber]) {
      groupedPDFs[groupNumber] = await PDFLib.PDFDocument.create();
    }

    const reader = new FileReader();

    reader.onload = async function() {
      const pdfBytes = new Uint8Array(reader.result);
      const pdf = await PDFLib.PDFDocument.load(pdfBytes);
      const pages = await groupedPDFs[groupNumber].copyPages(pdf, pdf.getPageIndices());

      pages.forEach((page) => {
        groupedPDFs[groupNumber].addPage(page);
      });

      if (i === inputFiles.length - 1) {
        for (const groupNumber in groupedPDFs) {
          const groupPdfBytes = await groupedPDFs[groupNumber].save();
          const filename = `group_${groupNumber}.pdf`;
          downloadPDF(groupPdfBytes, filename);
        }
      }
    };

    reader.readAsArrayBuffer(file);
  }
}

function downloadPDF(data, filename) {
  const a = document.createElement('a');
  const blob = new Blob([data], { type: 'application/pdf' });
  const url = URL.createObjectURL(blob);

  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();

  setTimeout(function() {
    document.body.removeChild(a);
    window.URL.revokeObjectURL(url);
  }, 0);
}

function isValidPageOrder(pageIndexes, pageCount) {
  if (pageIndexes.length !== pageCount) {
    return false;
  }

  const visited = new Set();

  for (const index of pageIndexes) {
    if (!Number.isInteger(index) || index < 1 || index > pageCount || visited.has(index)) {
return false;
}
    visited.add(index);
  }

  return true;
}

function isValidGroupNumbers(groupNumbers, fileCount) {
  if (groupNumbers.length !== fileCount) {
    return false;
  }

  const visited = new Set();

  for (const number of groupNumbers) {
    if (!Number.isInteger(number) || number < 1 || visited.has(number)) {
      return false;
    }

    visited.add(number);
  }

  return true;
}
</script>
</body>
</html>
